{"version":3,"sources":["trees/app.ts","trees/shapes.ts","trees/lighting.ts"],"names":["tree","renderer","scene","camera","leafModel","orbitControls","transformControls","stats","groundMaterial","createCylinder","rTop","rBottom","h","col","geometry","CylinderGeometry","material","MeshLambertMaterial","color","cylinder","Mesh","receiveShadow","castShadow","createSphere","r","opacity","SphereGeometry","transparent","sphere","loader","GLTFLoader","clock","Clock","minBranchLengthRange","minBranchLengthRatioRange","options","branchDensity","branchShortenRatio","flyAround","hasLeaves","height","leafSize","maxBranchAngle","minBranchLength","seed","treeColour","leafColour","groundColour","init","Scene","background","Color","showHelper","light","HemisphereLight","groundColor","setHSL","position","set","add","helper","HemisphereLightHelper","addHemisphereLight","DirectionalLight","multiplyScalar","shadow","mapSize","width","d","left","right","top","bottom","DirectionalLightHelper","addDirectionalLight","groundGeo","PlaneGeometry","ground","y","rotation","x","Math","PI","gui","GUI","buttonHandlers","newSeed","MathUtils","randInt","createTree","newSeedButton","name","domElement","parentElement","id","treeFolder","addFolder","open","leavesFolder","listen","onFinishChange","addColor","worldFolder","setHex","createGUI","WebGLRenderer","antialias","window","devicePixelRatio","powerPreference","setSize","innerWidth","innerHeight","setPixelRatio","outputEncoding","sRGBEncoding","shadowMap","enabled","document","body","appendChild","Stats","dom","PerspectiveCamera","OrbitControls","TransformControls","addEventListener","seededRandom","remove","Group","makeTree","Vector3","animate","requestAnimationFrame","getElapsedTime","cos","elapsedTime","z","sin","lookAt","update","render","length","pos","rz","ry","group","branchDirection","addLeaf","branchColour","offsetHSL","branchSegment","applyAxisAngle","endOfBranchPos","clone","isLargerBranch","drawingTrunk","knot","numberOfBranches","getBranchCount","i","degToRad","randomFloatFromInterval","mapLinear","randomIntFromInterval","scale","rx","leaf","setFromVector3","bbox","Box3","setFromObject","center","getCenter","size","getSize","copy","rotationParent","traverse","child","newMaterial","min","max","floor","load","gltf","undefined","error","console"],"mappings":"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","file":"static/js/main.20398a82.chunk.js","sourcesContent":["import {\n  Vector3,\n  Clock,\n  MathUtils,\n  Scene,\n  WebGLRenderer,\n  Color,\n  PerspectiveCamera,\n  Group,\n  MeshLambertMaterial,\n  Mesh,\n  SphereGeometry,\n  Box3,\n  ShaderMaterial,\n  BackSide,\n  PlaneGeometry,\n  sRGBEncoding,\n  PointLight,\n} from \"three\";\n\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { TransformControls } from \"three/examples/jsm/controls/TransformControls\";\nimport Stats from \"three/examples/jsm/libs/stats.module\";\nimport { GUI } from \"three/examples/jsm/libs/dat.gui.module\";\nimport { vertexShaderSource, fragmentShaderSource } from \"./shaders\";\nimport { createCylinder, createSphere } from \"./shapes\";\nimport { addDirectionalLight, addHemisphereLight } from \"./lighting\";\n\ntype Options = {\n  branchShortenRatio: number;\n  branchDensity: number;\n  flyAround: boolean;\n  hasLeaves: boolean;\n  height: number;\n  leafSize: number;\n  maxBranchAngle: number;\n  minBranchLength: number;\n  seed: number;\n  treeColour: number;\n  leafColour: number;\n  groundColour: number;\n};\n\nconst loader = new GLTFLoader();\n\nconst clock = new Clock();\nlet delta: number;\nlet tree: Group;\nlet renderer: WebGLRenderer;\nlet scene: Scene;\nlet camera: PerspectiveCamera;\nlet leafModel: Group;\nlet orbitControls: OrbitControls;\nlet transformControls: TransformControls;\nlet stats: Stats;\nlet groundMaterial: MeshLambertMaterial;\n\nconst minBranchLengthRange = [2, 10];\nconst minBranchLengthRatioRange = [0.75, 0.9];\n\nlet options: Options = {\n  branchDensity: 0.2,\n  branchShortenRatio: 0.75,\n  flyAround: true,\n  hasLeaves: true,\n  height: 20,\n  leafSize: 25,\n  maxBranchAngle: 95,\n  minBranchLength: 3,\n  seed: 8883, //MathUtils.randInt(0, 10000),\n  treeColour: 0x382718,\n  leafColour: 0x6b6a06,\n  groundColour: 0x89895d,\n};\n\nexport const go = () => {\n  loader.load(\n    \"assets/leaf/scene.gltf\",\n    function (gltf) {\n      leafModel = gltf.scene.clone();\n      leafModel.castShadow = true;\n      leafModel.receiveShadow = true;\n      init();\n      animate();\n    },\n    undefined,\n    function (error) {\n      console.error(error);\n    }\n  );\n};\n\nconst init = () => {\n  scene = new Scene();\n  scene.background = new Color(0xcce0ff);\n\n  // LIGHTS\n  const hemisphereLightColour = new Color().setHSL(0.6, 1, 0.6);\n  addHemisphereLight(hemisphereLightColour, scene);\n  addDirectionalLight(scene);\n\n  // GROUND\n  const groundGeo = new PlaneGeometry(1000, 1000);\n  groundMaterial = new MeshLambertMaterial({ color: options.groundColour });\n\n  const ground = new Mesh(groundGeo, groundMaterial);\n  ground.position.y = -40;\n  ground.rotation.x = -Math.PI / 2;\n  ground.receiveShadow = true;\n  scene.add(ground);\n\n  // GUI\n  createGUI();\n\n  //RENDERER\n  renderer = new WebGLRenderer({\n    antialias: window.devicePixelRatio === 1,\n    powerPreference: \"high-performance\",\n  });\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.outputEncoding = sRGBEncoding;\n  renderer.shadowMap.enabled = true;\n  document.body.appendChild(renderer.domElement);\n\n  stats = new (Stats as any)();\n  document.body.appendChild(stats.dom);\n\n  camera = new PerspectiveCamera(\n    30,\n    window.innerWidth / window.innerHeight,\n    1,\n    500\n  );\n  camera.position.set(0, 100, 200);\n\n  orbitControls = new OrbitControls(camera, renderer.domElement);\n\n  transformControls = new TransformControls(camera, renderer.domElement);\n  scene.add(transformControls);\n  transformControls.addEventListener(\"mouseDown\", function () {\n    orbitControls.enabled = false;\n  });\n  transformControls.addEventListener(\"mouseUp\", function () {\n    orbitControls.enabled = true;\n  });\n\n  createTree();\n};\n\nconst createTree = () => {\n  MathUtils.seededRandom(options.seed);\n  scene.remove(tree);\n  tree = new Group();\n  makeTree(options.height, new Vector3(0, 0, 0), 0, 0, options.height / 10);\n  scene.add(tree);\n  tree.position.set(0, -40, 0);\n};\n\nexport const animate = () => {\n  requestAnimationFrame(animate);\n\n  clock.getElapsedTime();\n\n  if (options.flyAround) {\n    const radius = 200;\n    camera.position.x =\n      tree.position.x + radius * Math.cos(0.4 * clock.elapsedTime);\n    camera.position.z =\n      tree.position.z + radius * Math.sin(0.4 * clock.elapsedTime);\n    camera.position.y =\n      90 + (tree.position.y + 35 * Math.sin(0.2 * clock.elapsedTime));\n\n    camera.lookAt(tree.position);\n  }\n\n  orbitControls.update();\n  stats.update();\n  renderer.render(scene, camera);\n};\n\nfunction makeTree(\n  length: number,\n  pos: Vector3,\n  rz: number,\n  ry: number,\n  rBottom: number = length / 20\n) {\n  const rTop = rBottom * 0.66;\n\n  //Create a group that will serve as the center of rotation\n  const group = new Group();\n  const branchDirection = new Vector3(0, 1, 0);\n  group.position.set(pos.x, pos.y, pos.z);\n\n  if (length < options.minBranchLength) {\n    addLeaf(group);\n    tree.add(group);\n\n    return;\n  }\n\n  const branchColour = new Color()\n    .setHex(options.treeColour)\n    .offsetHSL(0, MathUtils.seededRandom() / 10, MathUtils.seededRandom() / 8);\n  const branchSegment = createCylinder(rTop, rBottom, length, branchColour);\n  group.add(branchSegment);\n  tree.add(group);\n\n  branchSegment.position.y += length / 2;\n\n  // The rotation is done in two steps, a rotation around the Z axis followed by a rotation around the Y axis\n  group.rotation.z = rz;\n  branchDirection.applyAxisAngle(new Vector3(0, 0, 1), rz);\n\n  group.rotation.y = ry;\n  branchDirection.applyAxisAngle(new Vector3(0, 1, 0), ry);\n\n  // Scale the direction vector to easily find the endpoint of the branch (which is also the start point of the next branches)\n  branchDirection.multiplyScalar(length);\n\n  const endOfBranchPos = pos.clone().add(branchDirection);\n\n  const isLargerBranch = length > options.height / 3;\n  const drawingTrunk = length === options.height;\n  if (isLargerBranch) {\n    // fill in the gaps between the larger branches with spheres\n    if (!drawingTrunk) {\n      const knot = createSphere(rTop * 1.5, branchColour);\n      group.add(knot);\n    }\n  } else {\n    if (!drawingTrunk) {\n      // add leaves to the branch\n      addLeaf(group);\n      tree.add(group);\n    }\n  }\n\n  const numberOfBranches = getBranchCount();\n  for (let i = 0; i < numberOfBranches; i++) {\n    rz = MathUtils.degToRad(\n      randomFloatFromInterval(-options.maxBranchAngle, options.maxBranchAngle)\n    );\n    ry = MathUtils.degToRad(\n      randomFloatFromInterval(-options.maxBranchAngle, options.maxBranchAngle)\n    );\n\n    makeTree(\n      length *\n        MathUtils.mapLinear(\n          options.minBranchLength,\n          minBranchLengthRange[0],\n          minBranchLengthRange[1],\n          minBranchLengthRatioRange[0],\n          minBranchLengthRatioRange[1]\n        ),\n      endOfBranchPos,\n      rz,\n      ry,\n      rTop\n    );\n  }\n}\n\nfunction getBranchCount() {\n  const rnd = MathUtils.seededRandom();\n  return rnd < 1 - options.branchDensity\n    ? randomIntFromInterval(1, 2)\n    : randomIntFromInterval(3, 4);\n}\n\nfunction addLeaf(group: Group) {\n  const scale = options.leafSize * MathUtils.seededRandom();\n  const rx = MathUtils.degToRad(360 * MathUtils.seededRandom());\n  const rz = MathUtils.degToRad(360 * MathUtils.seededRandom());\n\n  const leafColour = new Color()\n    .setHex(options.leafColour)\n    .offsetHSL(\n      MathUtils.seededRandom() / 10,\n      MathUtils.seededRandom() / 10,\n      MathUtils.seededRandom() / 8\n    );\n\n  if (!options.hasLeaves) {\n    return;\n  }\n\n  const leaf = leafModel.clone();\n  leaf.rotation.setFromVector3(new Vector3(0, 0, 0));\n\n  // scale and re-position\n  // -------------\n  const bbox = new Box3().setFromObject(leaf);\n  const center = bbox.getCenter(new Vector3());\n  const size = bbox.getSize(new Vector3());\n  leaf.scale.set(scale, scale, scale);\n\n  bbox.setFromObject(leaf);\n  bbox.getCenter(center);\n  bbox.getSize(size);\n\n  var box = new Box3().setFromObject(leaf);\n  box.getCenter(leaf.position); // this re-sets the leaf position\n  leaf.position.add(new Vector3(0, 0, size.z / 2));\n  leaf.position.multiplyScalar(-1);\n\n  leaf.position.copy(center).multiplyScalar(-1);\n  // -------------\n  // end scale and re-position\n\n  var rotationParent = new Group();\n  rotationParent.add(leaf);\n\n  // re-position the leaf stem to the centre of the parent\n  // so it becomes the pivot point for rotation\n  leaf.position.z -= size.z * 0.45;\n  leaf.position.x += size.x * 0.0075;\n  leaf.position.y += size.y * 0.01;\n\n  rotationParent.rotation.x = rx;\n  rotationParent.rotation.z = rz;\n  leaf.traverse(function (child) {\n    if (child as Mesh) {\n      var newMaterial = new MeshLambertMaterial({\n        color: leafColour,\n      });\n      (child as Mesh).material = newMaterial;\n\n      child.castShadow = true;\n      child.receiveShadow = true;\n    }\n  });\n\n  group.add(rotationParent);\n}\n\nfunction createGUI() {\n  const gui = new GUI();\n  var buttonHandlers = {\n    newSeed: function () {\n      options.seed = MathUtils.randInt(0, 10000);\n      createTree();\n    },\n  };\n  const newSeedButton = gui.add(buttonHandlers, \"newSeed\").name(\"Random Tree\");\n  if (newSeedButton.domElement.parentElement) {\n    newSeedButton.domElement.parentElement.id = \"new-seed-button\";\n  }\n\n  const treeFolder = gui.addFolder(\"Tree\");\n  treeFolder.open();\n  const leavesFolder = gui.addFolder(\"Leaves\");\n  leavesFolder.open();\n  treeFolder\n    .add(options, \"seed\")\n    .name(\"Seed\")\n    .listen()\n    .onFinishChange(createTree);\n  treeFolder\n    .add(options, \"height\", 10, 30, 5)\n    .name(\"Height\")\n    .onFinishChange(createTree);\n  treeFolder\n    .add(\n      options,\n      \"minBranchLength\",\n      minBranchLengthRange[0],\n      minBranchLengthRange[1],\n      1\n    )\n    .name(\"Min. Branch Length\")\n    .onFinishChange(createTree);\n  treeFolder\n    .add(options, \"maxBranchAngle\", 30, 180, 5)\n    .name(\"Max. Angle\")\n    .onFinishChange(createTree);\n  treeFolder\n    .add(options, \"branchDensity\", 0.1, 0.5, 0.1)\n    .name(\"Branch Density\")\n    .onFinishChange(createTree);\n  treeFolder\n    .addColor(options, \"treeColour\")\n    .name(\"Colour\")\n    .onFinishChange(createTree);\n\n  leavesFolder\n    .add(options, \"hasLeaves\")\n    .name(\"Show?\")\n    .onFinishChange(createTree);\n  leavesFolder\n    .add(options, \"leafSize\", 10, 40, 5)\n    .name(\"Size\")\n    .onFinishChange(createTree);\n  leavesFolder\n    .addColor(options, \"leafColour\")\n    .name(\"Colour\")\n    .onFinishChange(createTree);\n\n  const worldFolder = gui.addFolder(\"World\");\n  worldFolder.add(options, \"flyAround\").name(\"Fly Around\");\n  worldFolder\n    .addColor(options, \"groundColour\")\n    .name(\"Ground Colour\")\n    .onFinishChange(() => {\n      groundMaterial.color.setHex(options.groundColour);\n    });\n  worldFolder.open();\n}\n\nfunction randomIntFromInterval(min: number, max: number) {\n  // min and max included\n  return Math.floor(MathUtils.seededRandom() * (max - min + 1) + min);\n}\n\nfunction randomFloatFromInterval(min: number, max: number) {\n  return MathUtils.seededRandom() * (max - min) + min;\n}\n","import {\n  CylinderGeometry,\n  MeshLambertMaterial,\n  Mesh,\n  SphereGeometry,\n  ColorRepresentation,\n} from \"three\";\n\nexport const createCylinder = (\n  rTop: number,\n  rBottom: number,\n  h: number,\n  col: ColorRepresentation\n) => {\n  const geometry = new CylinderGeometry(rTop, rBottom, h, 6, 1);\n  const material = new MeshLambertMaterial({ color: col });\n  const cylinder = new Mesh(geometry, material);\n  cylinder.receiveShadow = true;\n  cylinder.castShadow = true;\n  return cylinder;\n};\n\nexport const createSphere = (\n  r: number,\n  col: ColorRepresentation,\n  opacity = 1\n) => {\n  const geometry = new SphereGeometry(r, 16, 16);\n  const material = new MeshLambertMaterial({\n    color: col,\n    transparent: true,\n    opacity,\n  });\n  const sphere = new Mesh(geometry, material);\n  sphere.receiveShadow = true;\n  sphere.castShadow = true;\n  return sphere;\n};\n","import {\n  Color,\n  DirectionalLight,\n  DirectionalLightHelper,\n  HemisphereLight,\n  HemisphereLightHelper,\n  Scene,\n} from \"three\";\n\nexport const addHemisphereLight = (\n  color: Color,\n  scene: Scene,\n  showHelper = false\n) => {\n  const light = new HemisphereLight(0xffffff, 0xffffff, 0.3);\n  light.color = color;\n  light.groundColor.setHSL(0.095, 1, 0.75);\n  light.position.set(0, 50, 0);\n  scene.add(light);\n\n  if (showHelper) {\n    const helper = new HemisphereLightHelper(light, 10);\n    scene.add(helper);\n  }\n};\n\nexport const addDirectionalLight = (scene: Scene, showHelper = false) => {\n  const light = new DirectionalLight(0xffffff, 1);\n  light.color.setHSL(0.1, 1, 0.95);\n  light.position.set(-1, 1.75, 1);\n  light.position.multiplyScalar(30);\n  scene.add(light);\n\n  light.castShadow = true;\n\n  light.shadow.mapSize.width = 2048;\n  light.shadow.mapSize.height = 2048;\n\n  const d = 40;\n\n  light.shadow.camera.left = -d;\n  light.shadow.camera.right = d;\n  light.shadow.camera.top = d;\n  light.shadow.camera.bottom = -d;\n\n  if (showHelper) {\n    const helper = new DirectionalLightHelper(light, 10);\n    scene.add(helper);\n  }\n};\n"],"sourceRoot":""}