{"version":3,"sources":["trees/app.ts","trees/shapes.ts","trees/lighting.ts","trees/shaders.ts"],"names":["tree","renderer","scene","camera","leafModel","orbitControls","transformControls","stats","groundMaterial","createCylinder","rTop","rBottom","h","col","geometry","CylinderGeometry","material","MeshLambertMaterial","color","cylinder","Mesh","receiveShadow","castShadow","createSphere","r","opacity","SphereGeometry","transparent","sphere","loader","GLTFLoader","clock","Clock","minBranchLengthRange","minBranchLengthRatioRange","options","branchDensity","branchShortenRatio","flyAround","hasLeaves","height","leafSize","maxBranchAngle","minBranchLength","seed","treeColour","leafColour","groundColour","init","Scene","background","Color","PerspectiveCamera","window","innerWidth","innerHeight","add","PointLight","position","set","hemisphereLightColour","setHSL","showHelper","light","HemisphereLight","groundColor","helper","HemisphereLightHelper","addHemisphereLight","DirectionalLight","multiplyScalar","shadow","mapSize","width","d","left","right","top","bottom","far","bias","DirectionalLightHelper","addDirectionalLight","groundGeo","PlaneGeometry","ground","y","rotation","x","Math","PI","uniforms","topColor","value","bottomColor","offset","exponent","copy","skyGeo","skyMat","ShaderMaterial","vertexShader","fragmentShader","side","BackSide","sky","gui","GUI","buttonHandlers","newSeed","MathUtils","randInt","createTree","newSeedButton","name","domElement","parentElement","id","treeFolder","addFolder","open","leavesFolder","listen","onFinishChange","addColor","worldFolder","setHex","createGUI","WebGLRenderer","antialias","devicePixelRatio","powerPreference","setSize","setPixelRatio","outputEncoding","sRGBEncoding","shadowMap","enabled","document","body","appendChild","Stats","dom","OrbitControls","TransformControls","addEventListener","seededRandom","remove","Group","makeTree","Vector3","animate","requestAnimationFrame","getElapsedTime","cos","elapsedTime","z","sin","lookAt","update","render","length","pos","rz","ry","group","branchDirection","addLeaf","branchColour","offsetHSL","branchSegment","applyAxisAngle","endOfBranchPos","clone","isLargerBranch","drawingTrunk","knot","numberOfBranches","getBranchCount","i","degToRad","randomFloatFromInterval","mapLinear","randomIntFromInterval","scale","rx","leaf","setFromVector3","bbox","Box3","setFromObject","center","getCenter","size","getSize","rotationParent","traverse","child","newMaterial","min","max","floor","load","gltf","undefined","error","console"],"mappings":"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","file":"static/js/main.b561f3f3.chunk.js","sourcesContent":["import {\n  Vector3,\n  Clock,\n  MathUtils,\n  Scene,\n  WebGLRenderer,\n  Color,\n  PerspectiveCamera,\n  Group,\n  MeshLambertMaterial,\n  Mesh,\n  SphereGeometry,\n  Box3,\n  ShaderMaterial,\n  BackSide,\n  PlaneGeometry,\n  sRGBEncoding,\n  PointLight,\n} from \"three\";\n\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { TransformControls } from \"three/examples/jsm/controls/TransformControls\";\nimport Stats from \"three/examples/jsm/libs/stats.module\";\nimport { GUI } from \"three/examples/jsm/libs/dat.gui.module\";\nimport { vertexShaderSource, fragmentShaderSource } from \"./shaders\";\nimport { createCylinder, createSphere } from \"./shapes\";\nimport { addDirectionalLight, addHemisphereLight } from \"./lighting\";\n\ntype Options = {\n  branchShortenRatio: number;\n  branchDensity: number;\n  flyAround: boolean;\n  hasLeaves: boolean;\n  height: number;\n  leafSize: number;\n  maxBranchAngle: number;\n  minBranchLength: number;\n  seed: number;\n  treeColour: number;\n  leafColour: number;\n  groundColour: number;\n};\n\nconst loader = new GLTFLoader();\n\nconst clock = new Clock();\nlet delta: number;\nlet tree: Group;\nlet renderer: WebGLRenderer;\nlet scene: Scene;\nlet camera: PerspectiveCamera;\nlet leafModel: Group;\nlet orbitControls: OrbitControls;\nlet transformControls: TransformControls;\nlet stats: Stats;\nlet groundMaterial: MeshLambertMaterial;\n\nconst minBranchLengthRange = [2, 10];\nconst minBranchLengthRatioRange = [0.75, 0.9];\n\nlet options: Options = {\n  branchDensity: 0.2,\n  branchShortenRatio: 0.75,\n  flyAround: true,\n  hasLeaves: true,\n  height: 20,\n  leafSize: 25,\n  maxBranchAngle: 95,\n  minBranchLength: 3,\n  seed: 8883, //MathUtils.randInt(0, 10000),\n  treeColour: 0x382718,\n  leafColour: 0x6b6a06,\n  groundColour: 0x55552c,\n};\n\nexport const go = () => {\n  loader.load(\n    \"assets/leaf/scene.gltf\",\n    function (gltf) {\n      leafModel = gltf.scene.clone();\n      leafModel.castShadow = true;\n      leafModel.receiveShadow = true;\n      init();\n      animate();\n    },\n    undefined,\n    function (error) {\n      console.error(error);\n    }\n  );\n};\n\nconst init = () => {\n  scene = new Scene();\n  scene.background = new Color(0xcce0ff);\n\n  camera = new PerspectiveCamera(\n    30,\n    window.innerWidth / window.innerHeight,\n    1,\n    5\n  );\n  camera.add(new PointLight(0xffffff));\n  camera.position.set(0, 1, 5);\n\n  // LIGHTS\n  const hemisphereLightColour = new Color().setHSL(0.6, 1, 0.6);\n  addHemisphereLight(hemisphereLightColour, scene);\n  addDirectionalLight(scene);\n\n  // GROUND\n  const groundGeo = new PlaneGeometry(10000, 10000);\n  groundMaterial = new MeshLambertMaterial({ color: options.groundColour });\n\n  const ground = new Mesh(groundGeo, groundMaterial);\n  ground.position.y = -40;\n  ground.rotation.x = -Math.PI / 2;\n  ground.receiveShadow = true;\n  scene.add(ground);\n\n  // SKYDOME\n  const uniforms = {\n    topColor: { value: new Color(0x0077ff) },\n    bottomColor: { value: new Color(0xffffff) },\n    offset: { value: 33 },\n    exponent: { value: 0.6 },\n  };\n  uniforms[\"topColor\"].value.copy(hemisphereLightColour);\n\n  // scene.fog.color.copy(uniforms[\"bottomColor\"].value);\n\n  const skyGeo = new SphereGeometry(4000, 32, 15);\n  const skyMat = new ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: vertexShaderSource,\n    fragmentShader: fragmentShaderSource,\n    side: BackSide,\n  });\n  const sky = new Mesh(skyGeo, skyMat);\n  scene.add(sky);\n\n  // GUI\n  createGUI();\n\n  //RENDERER\n  renderer = new WebGLRenderer({\n    antialias: window.devicePixelRatio === 1,\n    powerPreference: \"high-performance\",\n  });\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.outputEncoding = sRGBEncoding;\n  renderer.shadowMap.enabled = true;\n  document.body.appendChild(renderer.domElement);\n\n  stats = new (Stats as any)();\n  document.body.appendChild(stats.dom);\n\n  camera = new PerspectiveCamera(\n    30,\n    window.innerWidth / window.innerHeight,\n    1,\n    500\n  );\n  camera.position.set(0, 100, 200);\n\n  orbitControls = new OrbitControls(camera, renderer.domElement);\n\n  transformControls = new TransformControls(camera, renderer.domElement);\n  scene.add(transformControls);\n  transformControls.addEventListener(\"mouseDown\", function () {\n    orbitControls.enabled = false;\n  });\n  transformControls.addEventListener(\"mouseUp\", function () {\n    orbitControls.enabled = true;\n  });\n\n  createTree();\n};\n\nconst createTree = () => {\n  MathUtils.seededRandom(options.seed);\n  scene.remove(tree);\n  tree = new Group();\n  makeTree(options.height, new Vector3(0, 0, 0), 0, 0, options.height / 10);\n  scene.add(tree);\n  tree.position.set(0, -40, 0);\n};\n\nexport const animate = () => {\n  requestAnimationFrame(animate);\n\n  clock.getElapsedTime();\n\n  if (options.flyAround) {\n    const radius = 200;\n    camera.position.x =\n      tree.position.x + radius * Math.cos(0.4 * clock.elapsedTime);\n    camera.position.z =\n      tree.position.z + radius * Math.sin(0.4 * clock.elapsedTime);\n    camera.position.y =\n      90 + (tree.position.y + 35 * Math.sin(0.2 * clock.elapsedTime));\n\n    camera.lookAt(tree.position);\n  }\n\n  orbitControls.update();\n  stats.update();\n  renderer.render(scene, camera);\n};\n\nfunction makeTree(\n  length: number,\n  pos: Vector3,\n  rz: number,\n  ry: number,\n  rBottom: number = length / 20\n) {\n  const rTop = rBottom * 0.66;\n\n  //Create a group that will serve as the center of rotation\n  const group = new Group();\n  const branchDirection = new Vector3(0, 1, 0);\n  group.position.set(pos.x, pos.y, pos.z);\n\n  if (length < options.minBranchLength) {\n    addLeaf(group);\n    tree.add(group);\n\n    return;\n  }\n\n  const branchColour = new Color()\n    .setHex(options.treeColour)\n    .offsetHSL(0, MathUtils.seededRandom() / 10, MathUtils.seededRandom() / 8);\n  const branchSegment = createCylinder(rTop, rBottom, length, branchColour);\n  group.add(branchSegment);\n  tree.add(group);\n\n  branchSegment.position.y += length / 2;\n\n  // The rotation is done in two steps, a rotation around the Z axis followed by a rotation around the Y axis\n  group.rotation.z = rz;\n  branchDirection.applyAxisAngle(new Vector3(0, 0, 1), rz);\n\n  group.rotation.y = ry;\n  branchDirection.applyAxisAngle(new Vector3(0, 1, 0), ry);\n\n  // Scale the direction vector to easily find the endpoint of the branch (which is also the start point of the next branches)\n  branchDirection.multiplyScalar(length);\n\n  const endOfBranchPos = pos.clone().add(branchDirection);\n\n  const isLargerBranch = length > options.height / 3;\n  const drawingTrunk = length === options.height;\n  if (isLargerBranch) {\n    // fill in the gaps between the larger branches with spheres\n    if (!drawingTrunk) {\n      const knot = createSphere(rTop * 1.5, branchColour);\n      group.add(knot);\n    }\n  } else {\n    if (!drawingTrunk) {\n      // add leaves to the branch\n      addLeaf(group);\n      tree.add(group);\n    }\n  }\n\n  const numberOfBranches = getBranchCount();\n  for (let i = 0; i < numberOfBranches; i++) {\n    rz = MathUtils.degToRad(\n      randomFloatFromInterval(-options.maxBranchAngle, options.maxBranchAngle)\n    );\n    ry = MathUtils.degToRad(\n      randomFloatFromInterval(-options.maxBranchAngle, options.maxBranchAngle)\n    );\n\n    makeTree(\n      length *\n        MathUtils.mapLinear(\n          options.minBranchLength,\n          minBranchLengthRange[0],\n          minBranchLengthRange[1],\n          minBranchLengthRatioRange[0],\n          minBranchLengthRatioRange[1]\n        ),\n      endOfBranchPos,\n      rz,\n      ry,\n      rTop\n    );\n  }\n}\n\nfunction getBranchCount() {\n  const rnd = MathUtils.seededRandom();\n  return rnd < 1 - options.branchDensity\n    ? randomIntFromInterval(1, 2)\n    : randomIntFromInterval(3, 4);\n}\n\nfunction addLeaf(group: Group) {\n  const scale = options.leafSize * MathUtils.seededRandom();\n  const rx = MathUtils.degToRad(360 * MathUtils.seededRandom());\n  const rz = MathUtils.degToRad(360 * MathUtils.seededRandom());\n\n  const leafColour = new Color()\n    .setHex(options.leafColour)\n    .offsetHSL(\n      MathUtils.seededRandom() / 10,\n      MathUtils.seededRandom() / 10,\n      MathUtils.seededRandom() / 8\n    );\n\n  if (!options.hasLeaves) {\n    return;\n  }\n\n  const leaf = leafModel.clone();\n  leaf.rotation.setFromVector3(new Vector3(0, 0, 0));\n\n  // scale and re-position\n  // -------------\n  const bbox = new Box3().setFromObject(leaf);\n  const center = bbox.getCenter(new Vector3());\n  const size = bbox.getSize(new Vector3());\n  leaf.scale.set(scale, scale, scale);\n\n  bbox.setFromObject(leaf);\n  bbox.getCenter(center);\n  bbox.getSize(size);\n\n  var box = new Box3().setFromObject(leaf);\n  box.getCenter(leaf.position); // this re-sets the leaf position\n  leaf.position.add(new Vector3(0, 0, size.z / 2));\n  leaf.position.multiplyScalar(-1);\n\n  leaf.position.copy(center).multiplyScalar(-1);\n  // -------------\n  // end scale and re-position\n\n  var rotationParent = new Group();\n  rotationParent.add(leaf);\n\n  // re-position the leaf stem to the centre of the parent\n  // so it becomes the pivot point for rotation\n  leaf.position.z -= size.z * 0.45;\n  leaf.position.x += size.x * 0.0075;\n  leaf.position.y += size.y * 0.01;\n\n  rotationParent.rotation.x = rx;\n  rotationParent.rotation.z = rz;\n  leaf.traverse(function (child) {\n    if (child as Mesh) {\n      var newMaterial = new MeshLambertMaterial({\n        color: leafColour,\n      });\n      (child as Mesh).material = newMaterial;\n\n      child.castShadow = true;\n      child.receiveShadow = true;\n    }\n  });\n\n  group.add(rotationParent);\n}\n\nfunction createGUI() {\n  const gui = new GUI();\n  var buttonHandlers = {\n    newSeed: function () {\n      options.seed = MathUtils.randInt(0, 10000);\n      createTree();\n    },\n  };\n  const newSeedButton = gui.add(buttonHandlers, \"newSeed\").name(\"Random Tree\");\n  if (newSeedButton.domElement.parentElement) {\n    newSeedButton.domElement.parentElement.id = \"new-seed-button\";\n  }\n\n  const treeFolder = gui.addFolder(\"Tree\");\n  treeFolder.open();\n  const leavesFolder = gui.addFolder(\"Leaves\");\n  leavesFolder.open();\n  treeFolder\n    .add(options, \"seed\")\n    .name(\"Seed\")\n    .listen()\n    .onFinishChange(createTree);\n  treeFolder\n    .add(options, \"height\", 10, 30, 5)\n    .name(\"Height\")\n    .onFinishChange(createTree);\n  treeFolder\n    .add(\n      options,\n      \"minBranchLength\",\n      minBranchLengthRange[0],\n      minBranchLengthRange[1],\n      1\n    )\n    .name(\"Min. Branch Length\")\n    .onFinishChange(createTree);\n  treeFolder\n    .add(options, \"maxBranchAngle\", 30, 180, 5)\n    .name(\"Max. Angle\")\n    .onFinishChange(createTree);\n  treeFolder\n    .add(options, \"branchDensity\", 0.1, 0.5, 0.1)\n    .name(\"Branch Density\")\n    .onFinishChange(createTree);\n  treeFolder\n    .addColor(options, \"treeColour\")\n    .name(\"Colour\")\n    .onFinishChange(createTree);\n\n  leavesFolder\n    .add(options, \"hasLeaves\")\n    .name(\"Show?\")\n    .onFinishChange(createTree);\n  leavesFolder\n    .add(options, \"leafSize\", 10, 40, 5)\n    .name(\"Size\")\n    .onFinishChange(createTree);\n  leavesFolder\n    .addColor(options, \"leafColour\")\n    .name(\"Colour\")\n    .onFinishChange(createTree);\n\n  const worldFolder = gui.addFolder(\"World\");\n  worldFolder.add(options, \"flyAround\").name(\"Fly Around\");\n  worldFolder\n    .addColor(options, \"groundColour\")\n    .name(\"Ground Colour\")\n    .onFinishChange(() => {\n      groundMaterial.color.setHex(options.groundColour);\n    });\n  worldFolder.open();\n}\n\nfunction randomIntFromInterval(min: number, max: number) {\n  // min and max included\n  return Math.floor(MathUtils.seededRandom() * (max - min + 1) + min);\n}\n\nfunction randomFloatFromInterval(min: number, max: number) {\n  return MathUtils.seededRandom() * (max - min) + min;\n}\n","import {\n  CylinderGeometry,\n  MeshLambertMaterial,\n  Mesh,\n  SphereGeometry,\n  ColorRepresentation,\n} from \"three\";\n\nexport const createCylinder = (\n  rTop: number,\n  rBottom: number,\n  h: number,\n  col: ColorRepresentation\n) => {\n  const geometry = new CylinderGeometry(rTop, rBottom, h, 6, 1);\n  const material = new MeshLambertMaterial({ color: col });\n  const cylinder = new Mesh(geometry, material);\n  cylinder.receiveShadow = true;\n  cylinder.castShadow = true;\n  return cylinder;\n};\n\nexport const createSphere = (\n  r: number,\n  col: ColorRepresentation,\n  opacity = 1\n) => {\n  const geometry = new SphereGeometry(r, 16, 16);\n  const material = new MeshLambertMaterial({\n    color: col,\n    transparent: true,\n    opacity,\n  });\n  const sphere = new Mesh(geometry, material);\n  sphere.receiveShadow = true;\n  sphere.castShadow = true;\n  return sphere;\n};\n","import {\n  Color,\n  DirectionalLight,\n  DirectionalLightHelper,\n  HemisphereLight,\n  HemisphereLightHelper,\n  Scene,\n} from \"three\";\n\nexport const addHemisphereLight = (\n  color: Color,\n  scene: Scene,\n  showHelper = false\n) => {\n  const light = new HemisphereLight(0xffffff, 0xffffff, 0.3);\n  light.color = color;\n  light.groundColor.setHSL(0.095, 1, 0.75);\n  light.position.set(0, 50, 0);\n  scene.add(light);\n\n  if (showHelper) {\n    const helper = new HemisphereLightHelper(light, 10);\n    scene.add(helper);\n  }\n};\n\nexport const addDirectionalLight = (scene: Scene, showHelper = false) => {\n  const light = new DirectionalLight(0xffffff, 1);\n  light.color.setHSL(0.1, 1, 0.95);\n  light.position.set(-1, 1.75, 1);\n  light.position.multiplyScalar(30);\n  scene.add(light);\n\n  light.castShadow = true;\n\n  light.shadow.mapSize.width = 2048;\n  light.shadow.mapSize.height = 2048;\n\n  const d = 50;\n\n  light.shadow.camera.left = -d;\n  light.shadow.camera.right = d;\n  light.shadow.camera.top = d;\n  light.shadow.camera.bottom = -d;\n\n  light.shadow.camera.far = 3500;\n  light.shadow.bias = -0.0001;\n\n  if (showHelper) {\n    const helper = new DirectionalLightHelper(light, 10);\n    scene.add(helper);\n  }\n};\n","export const vertexShaderSource = `\n  varying vec3 vWorldPosition;\n  void main() {\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n`;\n\nexport const fragmentShaderSource = `\n  uniform vec3 topColor;\n  uniform vec3 bottomColor;\n  uniform float offset;\n  uniform float exponent;\n  varying vec3 vWorldPosition;\n  void main() {\n    float h = normalize( vWorldPosition + offset ).y;\n    gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );\n  }\n`;\n"],"sourceRoot":""}