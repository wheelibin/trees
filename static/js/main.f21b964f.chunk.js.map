{"version":3,"sources":["trees/app.ts","trees/shapes.ts","trees/lighting.ts","index.tsx"],"names":["tree","renderer","scene","camera","leafModel","orbitControls","transformControls","stats","groundMaterial","createCylinder","rTop","rBottom","h","col","geometry","CylinderGeometry","material","MeshLambertMaterial","color","cylinder","Mesh","receiveShadow","castShadow","createSphere","r","opacity","SphereGeometry","transparent","sphere","loader","GLTFLoader","clock","Clock","minBranchLengthRange","minBranchLengthRatioRange","options","branchDensity","branchShortenRatio","flyAround","hasLeaves","height","leafSize","maxBranchAngle","minBranchLength","seed","treeColour","leafColour","groundColour","go","a","loadAsync","gltfLeaf","clone","init","animate","Scene","background","Color","showHelper","light","HemisphereLight","groundColor","setHSL","position","set","add","helper","HemisphereLightHelper","addHemisphereLight","DirectionalLight","multiplyScalar","shadow","mapSize","width","d","left","right","top","bottom","DirectionalLightHelper","addDirectionalLight","groundGeo","PlaneGeometry","ground","y","rotation","x","Math","PI","gui","GUI","buttonHandlers","newSeed","MathUtils","randInt","createTree","newSeedButton","name","domElement","parentElement","id","treeFolder","addFolder","open","leavesFolder","listen","onFinishChange","addColor","worldFolder","setHex","createGUI","WebGLRenderer","antialias","window","devicePixelRatio","powerPreference","setSize","innerWidth","innerHeight","setPixelRatio","outputEncoding","sRGBEncoding","shadowMap","enabled","document","body","appendChild","Stats","dom","PerspectiveCamera","OrbitControls","TransformControls","addEventListener","event","key","toUpperCase","setMode","seededRandom","remove","Group","makeTree","Vector3","requestAnimationFrame","getElapsedTime","cos","elapsedTime","z","sin","lookAt","update","render","length","pos","rz","ry","group","branchDirection","addLeaf","branchColour","offsetHSL","branchSegment","applyAxisAngle","endOfBranchPos","isLargerBranch","drawingTrunk","knot","numberOfBranches","getNumberOfBranches","i","degToRad","randomFloatFromInterval","mapLinear","randomIntFromInterval","scale","rx","leaf","setFromVector3","bbox","Box3","setFromObject","center","getCenter","size","getSize","copy","rotationParent","traverse","child","newMaterial","min","max","floor","app"],"mappings":"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","file":"static/js/main.f21b964f.chunk.js","sourcesContent":["import {\n  Vector3,\n  Clock,\n  MathUtils,\n  Scene,\n  WebGLRenderer,\n  Color,\n  PerspectiveCamera,\n  Group,\n  MeshLambertMaterial,\n  Mesh,\n  Box3,\n  PlaneGeometry,\n  sRGBEncoding,\n} from \"three\";\n\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { TransformControls } from \"three/examples/jsm/controls/TransformControls\";\nimport Stats from \"three/examples/jsm/libs/stats.module\";\nimport { GUI } from \"three/examples/jsm/libs/dat.gui.module\";\nimport { createCylinder, createSphere } from \"./shapes\";\nimport { addDirectionalLight, addHemisphereLight } from \"./lighting\";\n\ntype Options = {\n  branchShortenRatio: number;\n  branchDensity: number;\n  flyAround: boolean;\n  hasLeaves: boolean;\n  height: number;\n  leafSize: number;\n  maxBranchAngle: number;\n  minBranchLength: number;\n  seed: number;\n  treeColour: number;\n  leafColour: number;\n  groundColour: number;\n};\n\nconst loader = new GLTFLoader();\n\nconst clock = new Clock();\nlet tree: Group;\nlet renderer: WebGLRenderer;\nlet scene: Scene;\nlet camera: PerspectiveCamera;\nlet leafModel: Group;\nlet orbitControls: OrbitControls;\nlet transformControls: TransformControls;\nlet stats: Stats;\nlet groundMaterial: MeshLambertMaterial;\n\nconst minBranchLengthRange = [2, 10];\nconst minBranchLengthRatioRange = [0.75, 0.9];\n\nlet options: Options = {\n  branchDensity: 0.2,\n  branchShortenRatio: 0.75,\n  flyAround: true,\n  hasLeaves: true,\n  height: 20,\n  leafSize: 25,\n  maxBranchAngle: 95,\n  minBranchLength: 3,\n  seed: 8708, //MathUtils.randInt(0, 10000),\n  treeColour: 0x382718,\n  leafColour: 0x6b6a06,\n  groundColour: 0x89895d,\n};\n\nexport const go = async () => {\n  const gltfLeaf = await loader.loadAsync(\"assets/leaf/scene.gltf\");\n  leafModel = gltfLeaf.scene.clone();\n  leafModel.castShadow = true;\n  leafModel.receiveShadow = true;\n\n  init();\n  animate();\n};\n\nconst init = () => {\n  scene = new Scene();\n  scene.background = new Color(0xcce0ff);\n\n  // LIGHTS\n  const hemisphereLightColour = new Color().setHSL(0.6, 1, 0.6);\n  addHemisphereLight(hemisphereLightColour, scene);\n  addDirectionalLight(scene);\n\n  // GROUND\n  const groundGeo = new PlaneGeometry(1000, 1000);\n  groundMaterial = new MeshLambertMaterial({ color: options.groundColour });\n\n  const ground = new Mesh(groundGeo, groundMaterial);\n  ground.position.y = -40;\n  ground.rotation.x = -Math.PI / 2;\n  ground.receiveShadow = true;\n  scene.add(ground);\n\n  // GUI\n  createGUI();\n\n  //RENDERER\n  renderer = new WebGLRenderer({\n    antialias: window.devicePixelRatio === 1,\n    powerPreference: \"high-performance\",\n  });\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.outputEncoding = sRGBEncoding;\n  renderer.shadowMap.enabled = true;\n  document.body.appendChild(renderer.domElement);\n\n  stats = new (Stats as any)();\n  document.body.appendChild(stats.dom);\n\n  camera = new PerspectiveCamera(\n    30,\n    window.innerWidth / window.innerHeight,\n    1,\n    500\n  );\n  camera.position.set(0, 100, 200);\n\n  orbitControls = new OrbitControls(camera, renderer.domElement);\n\n  transformControls = new TransformControls(camera, renderer.domElement);\n  scene.add(transformControls);\n  transformControls.addEventListener(\"mouseDown\", function () {\n    orbitControls.enabled = false;\n  });\n  transformControls.addEventListener(\"mouseUp\", function () {\n    orbitControls.enabled = true;\n  });\n\n  window.addEventListener(\"keydown\", function (event) {\n    switch (event.key.toUpperCase()) {\n      case \"R\":\n        transformControls.setMode(\"rotate\");\n        break;\n      case \"V\":\n        transformControls.setMode(\"translate\");\n        break;\n\n      default:\n        break;\n    }\n  });\n\n  createTree();\n};\n\nconst createTree = () => {\n  MathUtils.seededRandom(options.seed);\n  scene.remove(tree);\n  tree = new Group();\n  makeTree(options.height, new Vector3(0, 0, 0), 0, 0, options.height / 10);\n  scene.add(tree);\n  tree.position.set(0, -40, 0);\n};\n\nexport const animate = () => {\n  requestAnimationFrame(animate);\n\n  clock.getElapsedTime();\n\n  if (options.flyAround) {\n    const radius = 200;\n    camera.position.x =\n      tree.position.x + radius * Math.cos(0.4 * clock.elapsedTime);\n    camera.position.z =\n      tree.position.z + radius * Math.sin(0.4 * clock.elapsedTime);\n    camera.position.y =\n      90 + (tree.position.y + 35 * Math.sin(0.2 * clock.elapsedTime));\n\n    camera.lookAt(tree.position);\n  }\n\n  orbitControls.update();\n  stats.update();\n  renderer.render(scene, camera);\n};\n\nfunction makeTree(\n  length: number,\n  pos: Vector3,\n  rz: number,\n  ry: number,\n  rBottom: number = length / 20\n) {\n  const rTop = rBottom * 0.66;\n\n  //Create a group that will serve as the center of rotation\n  const group = new Group();\n  const branchDirection = new Vector3(0, 1, 0);\n  group.position.set(pos.x, pos.y, pos.z);\n\n  if (length < options.minBranchLength) {\n    addLeaf(group);\n    tree.add(group);\n    return;\n  }\n\n  const branchColour = new Color()\n    .setHex(options.treeColour)\n    .offsetHSL(0, MathUtils.seededRandom() / 10, MathUtils.seededRandom() / 8);\n  const branchSegment = createCylinder(rTop, rBottom, length, branchColour);\n  group.add(branchSegment);\n  tree.add(group);\n\n  branchSegment.position.y += length / 2;\n\n  // The rotation is done in two steps, a rotation around the Z axis followed by a rotation around the Y axis\n  group.rotation.z = rz;\n  branchDirection.applyAxisAngle(new Vector3(0, 0, 1), rz);\n\n  group.rotation.y = ry;\n  branchDirection.applyAxisAngle(new Vector3(0, 1, 0), ry);\n\n  // Scale the direction vector to easily find the endpoint of the branch (which is also the start point of the next branches)\n  branchDirection.multiplyScalar(length);\n\n  const endOfBranchPos = pos.clone().add(branchDirection);\n\n  const isLargerBranch = length > options.height / 3;\n  const drawingTrunk = length === options.height;\n  if (isLargerBranch) {\n    // fill in the gaps between the larger branches with spheres\n    if (!drawingTrunk) {\n      const knot = createSphere(rTop * 1.5, branchColour);\n      group.add(knot);\n    }\n  } else {\n    if (!drawingTrunk) {\n      // add leaves to the branch\n      addLeaf(group);\n      tree.add(group);\n    }\n  }\n\n  const numberOfBranches = getNumberOfBranches();\n  for (let i = 0; i < numberOfBranches; i++) {\n    rz = MathUtils.degToRad(\n      randomFloatFromInterval(-options.maxBranchAngle, options.maxBranchAngle)\n    );\n    ry = MathUtils.degToRad(\n      randomFloatFromInterval(-options.maxBranchAngle, options.maxBranchAngle)\n    );\n\n    makeTree(\n      length *\n        MathUtils.mapLinear(\n          options.minBranchLength,\n          minBranchLengthRange[0],\n          minBranchLengthRange[1],\n          minBranchLengthRatioRange[0],\n          minBranchLengthRatioRange[1]\n        ),\n      endOfBranchPos,\n      rz,\n      ry,\n      rTop\n    );\n  }\n}\n\nfunction getNumberOfBranches() {\n  const rnd = MathUtils.seededRandom();\n  return rnd < 1 - options.branchDensity\n    ? randomIntFromInterval(1, 2)\n    : randomIntFromInterval(3, 4);\n}\n\nfunction addLeaf(group: Group) {\n  const scale = options.leafSize * MathUtils.seededRandom();\n  const rx = MathUtils.degToRad(360 * MathUtils.seededRandom());\n  const rz = MathUtils.degToRad(360 * MathUtils.seededRandom());\n\n  const leafColour = new Color()\n    .setHex(options.leafColour)\n    .offsetHSL(\n      MathUtils.seededRandom() / 10,\n      MathUtils.seededRandom() / 10,\n      MathUtils.seededRandom() / 8\n    );\n\n  if (!options.hasLeaves) {\n    return;\n  }\n\n  const leaf = leafModel.clone();\n  leaf.rotation.setFromVector3(new Vector3(0, 0, 0));\n\n  // scale and re-position\n  // -------------\n  const bbox = new Box3().setFromObject(leaf);\n  const center = bbox.getCenter(new Vector3());\n  const size = bbox.getSize(new Vector3());\n  leaf.scale.set(scale, scale, scale);\n\n  bbox.setFromObject(leaf);\n  bbox.getCenter(center);\n  bbox.getSize(size);\n\n  var box = new Box3().setFromObject(leaf);\n  box.getCenter(leaf.position); // this re-sets the leaf position\n  leaf.position.add(new Vector3(0, 0, size.z / 2));\n  leaf.position.multiplyScalar(-1);\n\n  leaf.position.copy(center).multiplyScalar(-1);\n  // -------------\n  // end scale and re-position\n\n  var rotationParent = new Group();\n  rotationParent.add(leaf);\n\n  // re-position the leaf stem to the centre of the parent\n  // so it becomes the pivot point for rotation\n  leaf.position.z -= size.z * 0.45;\n  leaf.position.x += size.x * 0.0075;\n  leaf.position.y += size.y * 0.01;\n\n  rotationParent.rotation.x = rx;\n  rotationParent.rotation.z = rz;\n  leaf.traverse(function (child) {\n    if (child as Mesh) {\n      var newMaterial = new MeshLambertMaterial({\n        color: leafColour,\n      });\n      (child as Mesh).material = newMaterial;\n\n      child.castShadow = true;\n      child.receiveShadow = true;\n    }\n  });\n\n  group.add(rotationParent);\n}\n\nfunction createGUI() {\n  const gui = new GUI();\n  var buttonHandlers = {\n    newSeed: function () {\n      options.seed = MathUtils.randInt(0, 10000);\n      createTree();\n    },\n  };\n  const newSeedButton = gui.add(buttonHandlers, \"newSeed\").name(\"Random Tree\");\n  if (newSeedButton.domElement.parentElement) {\n    newSeedButton.domElement.parentElement.id = \"new-seed-button\";\n  }\n\n  const treeFolder = gui.addFolder(\"Tree\");\n  treeFolder.open();\n  const leavesFolder = gui.addFolder(\"Leaves\");\n  leavesFolder.open();\n  treeFolder\n    .add(options, \"seed\")\n    .name(\"Seed\")\n    .listen()\n    .onFinishChange(createTree);\n  treeFolder\n    .add(options, \"height\", 10, 30, 5)\n    .name(\"Height\")\n    .onFinishChange(createTree);\n  treeFolder\n    .add(\n      options,\n      \"minBranchLength\",\n      minBranchLengthRange[0],\n      minBranchLengthRange[1],\n      1\n    )\n    .name(\"Min. Branch Length\")\n    .onFinishChange(createTree);\n  treeFolder\n    .add(options, \"maxBranchAngle\", 30, 180, 5)\n    .name(\"Max. Angle\")\n    .onFinishChange(createTree);\n  treeFolder\n    .add(options, \"branchDensity\", 0.1, 0.5, 0.1)\n    .name(\"Branch Density\")\n    .onFinishChange(createTree);\n  treeFolder\n    .addColor(options, \"treeColour\")\n    .name(\"Colour\")\n    .onFinishChange(createTree);\n\n  leavesFolder\n    .add(options, \"hasLeaves\")\n    .name(\"Show?\")\n    .onFinishChange(createTree);\n  leavesFolder\n    .add(options, \"leafSize\", 10, 40, 5)\n    .name(\"Size\")\n    .onFinishChange(createTree);\n  leavesFolder\n    .addColor(options, \"leafColour\")\n    .name(\"Colour\")\n    .onFinishChange(createTree);\n\n  const worldFolder = gui.addFolder(\"World\");\n  worldFolder.add(options, \"flyAround\").name(\"Fly Around\");\n  worldFolder\n    .addColor(options, \"groundColour\")\n    .name(\"Ground Colour\")\n    .onFinishChange(() => {\n      groundMaterial.color.setHex(options.groundColour);\n    });\n  worldFolder.open();\n}\n\nfunction randomIntFromInterval(min: number, max: number) {\n  // min and max included\n  return Math.floor(MathUtils.seededRandom() * (max - min + 1) + min);\n}\n\nfunction randomFloatFromInterval(min: number, max: number) {\n  return MathUtils.seededRandom() * (max - min) + min;\n}\n","import {\n  CylinderGeometry,\n  MeshLambertMaterial,\n  Mesh,\n  SphereGeometry,\n  ColorRepresentation,\n} from \"three\";\n\nexport const createCylinder = (\n  rTop: number,\n  rBottom: number,\n  h: number,\n  col: ColorRepresentation\n) => {\n  const geometry = new CylinderGeometry(rTop, rBottom, h, 6, 1);\n  const material = new MeshLambertMaterial({ color: col });\n  const cylinder = new Mesh(geometry, material);\n  cylinder.receiveShadow = true;\n  cylinder.castShadow = true;\n  return cylinder;\n};\n\nexport const createSphere = (\n  r: number,\n  col: ColorRepresentation,\n  opacity = 1\n) => {\n  const geometry = new SphereGeometry(r, 16, 16);\n  const material = new MeshLambertMaterial({\n    color: col,\n    transparent: true,\n    opacity,\n  });\n  const sphere = new Mesh(geometry, material);\n  sphere.receiveShadow = true;\n  sphere.castShadow = true;\n  return sphere;\n};\n","import {\n  Color,\n  DirectionalLight,\n  DirectionalLightHelper,\n  HemisphereLight,\n  HemisphereLightHelper,\n  Scene,\n} from \"three\";\n\nexport const addHemisphereLight = (\n  color: Color,\n  scene: Scene,\n  showHelper = false\n) => {\n  const light = new HemisphereLight(0xffffff, 0xffffff, 0.3);\n  light.color = color;\n  light.groundColor.setHSL(0.095, 1, 0.75);\n  light.position.set(0, 50, 0);\n  scene.add(light);\n\n  if (showHelper) {\n    const helper = new HemisphereLightHelper(light, 10);\n    scene.add(helper);\n  }\n};\n\nexport const addDirectionalLight = (scene: Scene, showHelper = false) => {\n  const light = new DirectionalLight(0xffffff, 1);\n  light.color.setHSL(0.1, 1, 0.95);\n  light.position.set(-1, 1.75, 1);\n  light.position.multiplyScalar(30);\n  scene.add(light);\n\n  light.castShadow = true;\n\n  light.shadow.mapSize.width = 2048;\n  light.shadow.mapSize.height = 2048;\n\n  const d = 40;\n\n  light.shadow.camera.left = -d;\n  light.shadow.camera.right = d;\n  light.shadow.camera.top = d;\n  light.shadow.camera.bottom = -d;\n\n  if (showHelper) {\n    const helper = new DirectionalLightHelper(light, 10);\n    scene.add(helper);\n  }\n};\n","import \"./index.css\";\n\nimport * as app from \"./trees/app\";\n\napp.go();\n"],"sourceRoot":""}